---
title: TCP 状态机
cover: https://s2.loli.net/2022/12/24/FI1YkGehQyVKs9T.jpg
tags: [Computer Network]
date: 2022-09-23
categories: [Network]
---

# TCP 状态机

一个 TCP 连接在它的生命周期内会有不同的状态。

下图说明了 TCP 连接可能会有的状态，以及基于事件的状态转换。事件中有的是应用程序的操作，有的是接收到了网络发过来的请求。

![a21r1-84lt6.jpg](https://s2.loli.net/2022/12/25/kbcDZ3WdeETio8u.jpg)

TCP 状态及其描述如下表。

| 状态         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| LISTEN       | 等待来自远程 TCP 应用程序的请求                                |
| SYN_SENT     | 发送连接请求后等待来自远程端点的确认。TCP 第一次握手后客户端所处的状态 |
| SYN-RECEIVED | 该端点已经接收到连接请求并发送确认。该端点正在等待最终确认。TCP 第二次握手后服务端所处的状态 |
| ESTABLISHED  | 代表连接已经建立起来了。这是连接数据传输阶段的正常状态       |
| FIN_WAIT_1   | 等待来自远程 TCP 的终止连接请求或终止请求的确认                |
| FIN_WAIT_2   | 在此端点发送终止连接请求后，等待来自远程 TCP 的连接终止请求    |
| CLOSE_WAIT   | 该端点已经收到来自远程端点的关闭请求，此 TCP 正在等待本地应用程序的连接终止请求 |
| CLOSING      | 等待来自远程 TCP 的连接终止请求确认                            |
| LAST_ACK     | 等待先前发送到远程 TCP 的连接终止请求的确认                    |
| TIME_WAIT    | 等待足够的时间来确保远程 TCP 接收到其连接终止请求的确认        |

<!-- more -->

## TCP 三次握手

当一个 TCP 连接建立时，发生了以下事情：

1. 服务端必须准备接收传入的连接。这通常通过调用`socket`，`bind`和`listen`来完成，称为被动打开。
2. 客户端通过调用`connect`方法来发起一个主动的打开。客户端 TCP 会发送一个“同步”(SYN) 段，它告诉服务器客户端在连接上发送的数据的初始序列号。通常情况下，SYN 没有发送数据，它只包含一个 IP 头，TCP 头和可能的 TCP 选项。
3. 服务器必须确认（ACK）客户端的 SYN，并且服务器还必须发送自己的 SYN，其中包含服务器将在连接上发送的数据的初始序列号。
4. 客户端必须确认服务器的 SYN。

下图显示了 TCP 三次握手的过程，以及客户端和服务端状态的变化。

![ac793-tjj85.jpg](https://s2.loli.net/2022/12/25/NvTBnJWulGCPZk7.jpg)

## TCP 四次挥手

一个 TCP 连接需要四步断开：

1. 一个应用程序首先执行`close`，发送 FIN 段，这个操作被称为主动关闭，这意味着这一端完成数据的发送。
2. 执行 FIN 的另一端执行被动关闭，该端发送 ACK，确认该 FIN。
3. 被动关闭的一端执行`close`，向主动关闭的一方发送 FIN。
4. 主动关闭的一方确认收到的 FIN。

下图显示了一次典型的 TCP 四次挥手的过程，以及主动关闭方和被动关闭方的状态变化。在图中是客户端主动断开了连接，这里只是举个例子，服务端一样可以主动断开连接。

![amjcz-udy5c.jpg](https://s2.loli.net/2022/12/25/ZLbSedsukzPBChD.jpg)

## 关于 TIME_WAIT 状态

TIME_WAIT 状态应该是最让人疑惑的一个状态了。在上图中可以看到，执行主动断开的节点最后会进入这个状态，该节点会在此状态保存 2 倍的 MSL（最大段生存期）。

TCP 的每个实现都必须为 MSL 选择一个值。RFC 1122 推荐的值为两分钟，伯克利派的实现使用 30 秒。这也就是说 TIME_WAIT 状态会维持 1 到 4 分钟。MSL 是任何 IP 数据报可以在网络中生存的最长时间。这个时间是有限制的，因为每个数据报都包含一个 8 位的跳数限制，最大值是 255.虽然这是一个跳数限制而不是一个真正的时间限制，但是根据这个限制来假设数据报的最长生命周期依然是有意义的。

网络中数据报丢失的原因通常是路由异常。一旦路由崩溃或者两个路由之间的链路断开，路由协议需要几秒或几分钟才能稳定，并找到一条备用路径。在这段时间内，可能发生路由回路。同时假设丢失是一个 TCP 数据报，则发生 TCP 超时，并且重新发送分组，重传的分组通过一些备用路径达到最终目的地。但是一段时间后（该时间小于 MSL），路由循环被更正，在循环中丢失的数据报被发送到最终目的地。这个原始的数据报被称为丢失的副本或漫游副本。TCP 协议必须处理这些数据报。

维持 TIME_WAIT 有两个原因：

1. 可靠地实现 TCP 的全双工连接终止。
2. 允许旧的重复数据段在网络中过期

在四次挥手中，假设最后的 ACK 丢失了，被动关闭方会重发 FIN。主动关闭端必须维护状态，来允许被动关闭方重发最后的 ACK；如果它没有维护这个状态，将会对重发 FIN 返回 RST，被动关闭方会认为这是个错误。如果 TCP 正在执行彻底终止数据流的两个方向所需的所有工作（即全双工关闭），则必须正确处理这四个段中任何一个的丢失。所以执行主动关闭的一方必须在结束时保持 TIME_WAIT 状态：因为它可能必须重传最后的 ACK。

现在来聊维持 TIME_WAIT 状态的第二个原因。假设在主机 12.106.32.254 的 1500 端口和 206.168.112.219 的 21 端口之间有一个 TCP 连接。此连接关闭后，在相通的地址和端口建立了另外一个连接。由于 IP 地址和端口相同，所以后一种连接被称为先前连接的“化身”。TCP 必须防止连接中的旧副本在稍后再次出现，并被误解为属于同一连接的新“化身”。为此，TCP 将不会启动当前处于 TIME_WAIT 状态的连接的新“化身”。由于 TIME_WAIT 状态的持续时间时两倍的 MSL，因此 TCP 允许一个方向的数据在 MSL 秒内丢失，也允许回复在一个 MSL 秒内丢失。通过强制执行此规则，可以保证当一个 TCP 连接成功建立时，来自先前连接的所有旧的副本在网络中已过期。
